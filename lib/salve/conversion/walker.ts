/**
 * This module contains classes for walking a parsed tree.
 * @author Louis-Dominique Dubeau
 * @license MPL 2.0
 * @copyright Mangalam Research Center for Buddhist Languages
 */

import * as datatypes from "../datatypes";
import * as formats from "../formats";
import { Element } from "./parser";

// Table of names (string) to constructors.(function).
const nameToConstructor: any = formats.__protected.nameToConstructor;
const constructors: Function[] = [];
let ntocIx: number = 0;
while (nameToConstructor[ntocIx]) {
  constructors[ntocIx] = nameToConstructor[ntocIx];
  ntocIx++;
}

// Table of names (string) to corresponding type number.
const constructorNameToIndex: {[name: string]: number} = Object.create(null);

for (const name in nameToConstructor) {
  if (!(name in constructors)) {
    // Not a number
    constructorNameToIndex[name] = constructors.indexOf(nameToConstructor[name]);
  }
}

type ConstructState = {
  open: string,
  close: string,
  first: boolean,
};

/**
 * Base class for walkers.
 */
export abstract class ConversionWalker {
  /**
   * The output of the conversion as an array of strings to be concatenated.
   */
  readonly output: string[] = [];

  private _constructState: ConstructState[] =
    [{ open: "", close: "", first: true }];

  /**
   * Opens a construct in the output.
   *
   * @param open The opening string.
   *
   * @param close The closing string. This will be used to check that the
   * construct is closed properly.
   */
  openConstruct(open: string, close: string): void {
    this._constructState.unshift({ open, close, first: true });
    this.output.push(open);
  }

  /**
   * Closes a construct in the output.
   *
   * @param close The closing string. This will be used to check that the
   * construct is closed properly.
   *
   * @throws {Error} If the ``close`` parameter does not match what was passed to
   * [[openConstruct]].
   */
  closeConstruct(close: string): void {
    const top: ConstructState | undefined = this._constructState.shift();
    if (top) {
      if (close !== top.close) {
        throw new Error(`construct mismatch: ${top.close} vs ${close}`);
      }
      this.output.push(close);
    }
  }

  /**
   * Indicates that a new item is about to start in the current construct.
   * Outputs a separator (",") if this is not the first item in the construct.
   */
  newItem(): void {
    if (!this._constructState[0].first) {
      this.output.push(",");
    }
    this._constructState[0].first = false;
  }

  /**
   * Outputs an item in the current construct. Outputs a separator (",") if this
   * is not the first item in the construct.
   *
   * @param item The item to output.
   */
  outputItem(item: string | number): void {
    this.newItem();
    if (typeof item === "number") {
      item = `${item}`;
    }
    this.output.push(item);
  }

  /**
   * Outputs a string in the current construct. Outputs a separator (",") if this
   * is not the first item in the construct. The double-quotes in the string will
   * be escaped and the string will be surrounded by double quotes in the output.
   *
   * @param str The string to output.
   */
  outputString(str: string): void {
    this.newItem();
    this.output.push(JSON.stringify(str));
  }

  /**
   * Outputs a key-value pair. Both are strings. Outputs a separator (",") if
   * this is not the first item in the construct. The double-quotes in the
   * strings will be escaped and the strings will be surrounded by double quotes
   * in the output.
   *
   * @param key The key to output.
   * @param value The value to output.
   */
  outputKeyValue(key: string, value: string): void {
    this.newItem();

    this.output.push(JSON.stringify(key));
    this.output.push(":");
    this.output.push(JSON.stringify(value));
  }

  /**
   * Walks an element's children.
   *
   * @param el The element whose children must be walked.
   *
   * @param startAt Index at which to start walking.
   *
   * @param endAt Index at which to end walking. If unspecified, go to the end
   * of the children of ``el``.
   */
  walkChildren(el: Element, startAt: number = 0, endAt?: number): void {
    const children: Array<Element | string> = el.children;

    if (!endAt) {
      endAt = children.length;
    }

    const limit: number = Math.min(endAt, children.length);
    if (limit < startAt) {
      throw new Error("invalid parameters passed");
    }
    for (let i: number = startAt; i < limit; ++i) {
      const child: Element | string = children[i];
      if (child instanceof Element) {
        this.walk(child);
      }
    }
  }

  /**
   * Walk an element.
   *
   * @param el The element whose children must be walked.
   */
  abstract walk(el: Element): void;
}

/**
 * ConversionWalker for the default version generated by salve.
 */
export class DefaultConversionWalker extends ConversionWalker {
  protected readonly arrayStart: string | number;
  protected inNameClass: boolean = false;

  /**
   * @param version The version of the format to produce.
   *
   * @param includePaths Whether to include paths in the output.
   *
   * @param verbose Whether to output verbosely.
   *
   * @throws {Error} If the version requested in ``version`` is not supported.
   */
  constructor(version: number, readonly includePaths: boolean = false,
              readonly verbose: boolean = false) {
    super();
    if (version !== 3) {
      throw new Error("DefaultConversionWalker only supports version 3");
    }
    this.arrayStart = this.verbose ? "\"Array\"" : 0;
  }

  /**
   * Open an array in the output.
   */
  openArray(): void {
    this.openConstruct("[", "]");
    this.outputItem(this.arrayStart);
  }

  walk(el: Element): void {
    el.makePath();

    // Damn hoisting.
    let constructor: number;

    // This is the SAX node.
    const node: any = el.node;
    switch (node.local) {
    case "start":
      this.walkChildren(el);
      break;
    case "param":
      this.outputString(node.attributes.name.value);
      this.outputString(el.children[0] as string);
      break;
    case "grammar":
      this.openConstruct("{", "}");
      this.outputItem(`"v":3,"o":${this.includePaths ? 0 : 1},"d":`);
      // tslint:disable:no-string-literal
      constructor = constructorNameToIndex["Grammar"];
      if (!constructor) {
        throw new Error("can't find constructor for Grammar");
      }
      this.openConstruct("[", "]");
      if (this.verbose) {
        this.outputString("Grammar");
      }
      else {
        this.outputItem(constructor);
      }
      if (this.includePaths) {
        this.outputString(el.path!);
      }
      this.walk(el.children[0] as Element);
      this.newItem();
      this.openArray();
      this.walkChildren(el, 1);
      this.closeConstruct("]");
      this.closeConstruct("]");
      this.closeConstruct("}");
      break;
    default:
      let capitalized: string = node.local.charAt(0).toUpperCase() + node.local.slice(1);
      const skipToChildren: boolean = (capitalized === "Except");
      if (this.inNameClass) {
        // When we are in an name class, some elements are converted
        // differently from when outside it. For instance, choice can appear
        // as a general pattern to encode a choice between two elements or
        // two attributes, and it can be used inside a name class to encode a
        // choice between two names. We convert such elements to a different
        // class.
        if (capitalized === "Choice") {
          capitalized = "NameChoice";
        }
      }

      // We do not output anything for this element itself but instead go
      // straight to its children.
      if (skipToChildren) {
        this.walkChildren(el);
        return;
      }

      this.newItem();
      constructor = constructorNameToIndex[capitalized];
      if (!constructor) {
        throw new Error(`can't find constructor for ${capitalized}`);
      }

      this.openConstruct("[", "]");
      if (this.verbose) {
        this.outputString(capitalized);
      }
      else {
        this.outputItem(constructor);
      }
      if (this.includePaths) {
        this.outputString(el.path!);
      }

      let name: string;
      switch (node.local) {
      case "ref":
        name = node.attributes.name.value;
        if (typeof name === "number") {
          this.outputItem(name);
        }
        else {
          this.outputString(name);
        }
        break;
      case "define":
        name = node.attributes.name.value;
        if (typeof name === "number") {
          this.outputItem(name);
        }
        else {
          this.outputString(name);
        }
        this.newItem();
        this.openArray();
        this.walkChildren(el);
        this.closeConstruct("]");
        break;
      case "value":
        // Output a variable number of items.
        // Suppose item 0 is called it0 and so forth. Then:
        //
        // Number of items  value  type    datatypeLibrary  ns
        // 1                it0    "token" ""               ""
        // 2                it0     it1    ""               ""
        // 3                it0     it1    it2              ""
        // 4                it0     it1    it2              it3
        //
        this.outputString(el.children.join(""));
        if (node.attributes.type.value !== "token" ||
            node.attributes.datatypeLibrary.value !== "" ||
            node.attributes.ns.value !== "") {
          this.outputString(node.attributes.type.value);
          if (node.attributes.datatypeLibrary.value !== "" ||
              node.attributes.ns.value !== "") {
            this.outputString(node.attributes.datatypeLibrary.value);
            // No value === empty string.
            if (node.attributes.ns.value !== "") {
              this.outputString(node.attributes.ns.value);
            }
          }
        }
        break;
      case "data":
        // Output a variable number of items.
        // Suppose item 0 is called it0 and so forth. Then:
        //
        // Number of items  type    datatypeLibrary params except
        // 0                "token" ""              {}     undefined
        // 1                it0     ""              {}     undefined
        // 2                it0     it1             {}     undefined
        // 3                it0     it1             it2    undefined
        // 4                it0     it1             it2    it3
        //
        // Parameters are necessarily first among the children.
        const hasParams: boolean =
          (el.children.length !== 0 &&
           ((el.children[0] as Element).node.local === "param"));
        // Except is necessarily last.
        const hasExcept: boolean =
          (el.children.length !== 0 &&
           (el.children[el.children.length - 1] as Element).node.local ===
           "except");

        if (node.attributes.type.value !== "token" ||
            node.attributes.datatypeLibrary.value !== "" ||
            hasParams ||
            hasExcept) {
          this.outputString(node.attributes.type.value);
          if (node.attributes.datatypeLibrary.value !== "" ||
              hasParams ||
              hasExcept) {
            this.outputString(node.attributes.datatypeLibrary.value);
            if (hasParams || hasExcept) {
              this.newItem();
              this.openArray();
              if (hasParams) {
                this.walkChildren(el, 0, hasExcept ? el.children.length - 1 :
                                  undefined);
              }
              this.closeConstruct("]");
              if (hasExcept) {
                this.walk(el.children[el.children.length - 1] as Element);
              }
            }
          }
        }
        break;
      case "group":
      case "interleave":
      case "choice":
      case "oneOrMore":
        this.newItem();
        this.openArray();
        this.walkChildren(el);
        this.closeConstruct("]");
        break;
      case "element":
      case "attribute":
        // The first element of `<element>` or `<attribute>` is necessarily a name
        // class. Note that there is no need to owrry about recursivity since it
        // is not possible to get here recursively from the `this.walk` call that
        // follows. (A name class cannot contain `<element>` or `<attribute>`.
        this.inNameClass = true;
        this.walk(el.children[0] as Element);
        this.inNameClass = false;
        this.newItem();
        this.openArray();
        this.walkChildren(el, 1);
        this.closeConstruct("]");
        break;
      case "name":
        this.outputString(node.attributes.ns.value);
        this.outputString(el.children.join(""));
        break;
      case "nsName":
        this.outputString(node.attributes.ns.value);
        this.walkChildren(el);
        break;
      default:
        this.walkChildren(el);
      }
      this.closeConstruct("]");
      break;
    }
  }
}

/**
 * A ConversionWalker specialized in gathering the names used for Relax NG's
 * ``<ref>`` and ``<define>`` elements.
 */
export class NameGatherer extends ConversionWalker {
  /**
   * The names gathered. Each name is associated with the number of times it
   * was seen. This property is valid after the walker has walked the element
   * tree.
   */
  readonly names: {[name: string]: number} =  Object.create(null);

  walk(el: Element): void {
    this.walkChildren(el);
    if (el.node.local === "define" || el.node.local === "ref") {
      const name: string = el.node.attributes["name"].value;
      if (!(name in this.names)) {
        this.names[name] = 0;
      }

      this.names[name]++;
    }
  }
}

/**
 * A ConversionWalker specialized in reassinging the names used by Relax NG's
 * ``<ref>`` and ``<define>`` elements.
 *
 * @param names This is a map whose keys are the names that already exist in the
 * element tree and the values are the new names to use. A ``(key, value)`` pair
 * indicates that ``key`` should be replaced with ``value``. It is up to the
 * caller to ensure that two keys do not share the same value and that the map
 * is complete.
 */
export class Renamer extends ConversionWalker {
  constructor(protected names: {[name: string]: string}) {
    super();
  }

  walk(el: Element): void {
    if (el.node.local === "define" || el.node.local === "ref") {
      el.node.attributes["name"].value =
        this.names[el.node.attributes["name"].value];
    }
    this.walkChildren(el);
  }
}

const warnAboutTheseTypes: string[] = [
  "float",
  "double",
  "ENTITY",
  "ENTITIES",
];

/**
 * @private
 *
 * @param el Element to start the search from.
 *
 * @returns ``true`` if ``el`` is an attribute or is in an RNG
 * ``<attribute>`` element. ``false`` otherwise.
 */
function inAttribute(el: Element): boolean {
  let current: Element | undefined = el;
  while (current) {
    if (current.node && (current.node.local === "attribute")) {
      return true;
    }
    current = current.parent;
  }

  return false;
}

/**
 * Searches for an attribute on an element or on the ancestors of this element,
 * going from parent, to grand-parent, to grand-grand-parent, etc.
 *
 * @private
 *
 * @param el Element from which to search.
 *
 * @param name The name of the attribute.
 *
 * @returns The value of the attribute on the closest element that has the
 * attribute.
 */
function findAttributeUpwards(el: Element, name: string): string | undefined {
  let current: Element | undefined = el;
  while (current) {
    if (current.node && current.node.attributes[name]) {
      return current.node.attributes[name].value;
    }

    current = current.parent;
  }

  return undefined;
}

function localName(value: string): string {
  const sep: number = value.indexOf(":");
  return (sep === -1) ? value : value.slice(sep + 1);
}

function fromQNameToURI(value: string, el: Element): string {
  const attribute: boolean = inAttribute(el);
  let parts: string[] = value.split(":");

  if (parts.length === 1) { // If there is no prefix
    if (attribute) { // Attribute in undefined namespace
      return "";
    }

    // We are searching for the default namespace currently in effect.
    parts = ["", value];
  }

  if (parts.length > 2) {
    throw new Error("invalid name");
  }

  if (parts[0] === "") {
    // Yes, we return the empty string even if that what @ns is set to:
    // there is no default namespace when @ns is set to ''.
    return el.node.attributes["ns"].value;
  }

  // We have a prefix, in which case @ns is useless. We have to get the
  // namespace from @xmlns and @xmlns:prefix attributes.
  const uri: string | undefined =
    findAttributeUpwards(el, (parts[0] === "") ? "xmlns" :
                         (`xmlns:${parts[0]}`));
  if (!uri) {
    throw new Error(`cannot resolve prefix: ${parts[0]}`);
  }
  return uri;
}

/**
 * This walker checks that the types used in the tree can be used, and does
 * special processing for QName and NOTATION.
 */
export class DatatypeProcessor extends ConversionWalker {
  /**
   * The warnings generated during the walk. This array is populated while
   * walking.
   */
  readonly warnings: string[] = [];

  /**
   * An anonymous object whose keys are the
   * types that have been deemed incomplete. This object is populated while
   * walking walk.
   */
  readonly incompleteTypesUsed: {[name: string]: boolean} = Object.create(null);

  walk(el: Element): void {
    let libname: string | undefined;
    let type: string | undefined;

    if (el.node.local === "value") {
      el.makePath();
      const node: any = el.node;
      let value: string = el.children.join("");
      type = node.attributes.type.value;
      libname = node.attributes.datatypeLibrary.value;
      let ns: string = node.attributes.ns.value;

      const lib: datatypes.TypeLibrary | undefined =
        datatypes.registry.find(libname!);
      if (!lib) {
        throw new datatypes.ValueValidationError(
          [new datatypes.ValueError(`unknown datatype library: ${libname}`)]);
      }

      const datatype: datatypes.Datatype = lib.types[type!];
      if (!datatype) {
        throw new datatypes.ValueValidationError(
          [new datatypes.ValueError(`unknown datatype ${type} in ` +
                                    ((libname === "") ? "default library" :
                                     (`library ${libname}`)))]);
      }

      if (datatype.needsContext &&
          !(libname === "http://www.w3.org/2001/XMLSchema-datatypes" &&
            (type === "QName" || type === "NOTATION"))) {
        throw new Error("datatype needs context but is not " +
                        "QName or NOTATION form the XML Schema " +
                        "library: don't know how to handle");
      }

      if (datatype.needsContext) {
        // Change ns to the namespace we need.
        ns = node.attributes.ns.value = fromQNameToURI(value, el);
        value = localName(value);
        el.children.splice(0, el.children.length, value);
      }

      // Generating the element will cause salve to perform checks on the
      // params, etc. We do not need to record the return value.
      // tslint:disable:no-unused-new
      new nameToConstructor.Value(el.path, value, type, libname, ns);
    }
    else if (el.node.local === "data") {
      el.makePath();
      const node: any = el.node;
      // Except is necessarily last.
      const hasExcept: boolean =
        (el.children.length !== 0 &&
         (el.children[el.children.length - 1] as Element)
         .node.local === "except");

      type = node.attributes.type.value;
      libname = node.attributes.datatypeLibrary.value;
      const lib: datatypes.TypeLibrary | undefined =
        datatypes.registry.find(libname!);
      if (!lib) {
        throw new datatypes.ValueValidationError(
          [new datatypes.ValueError(`unknown datatype library: ${libname}`)]);
      }

      if (!lib.types[type!]) {
        throw new datatypes.ValueValidationError(
          [new datatypes.ValueError(`unknown datatype ${type} in ` +
                                    ((libname === "") ? "default library" :
                                     `library ${libname}`))]);
      }

      const params: any = el.children.slice(
        0, hasExcept ? el.children.length - 1 : undefined).map(
          (child: Element) => ({
              name: child.node.attributes["name"].value,
              value: child.children.join(""),
          }));

      // Generating the element will cause salve to perform checks on the params,
      // etc. We do not need to record the return value. Also, we do not need to
      // pass the possible exception, as it will be dealt when children of this
      // element are walked.
      // eslint-disable-next-line no-new
      new nameToConstructor.Data(el.path, type, libname, params);
    }

    if (libname === "http://www.w3.org/2001/XMLSchema-datatypes" &&
        warnAboutTheseTypes.indexOf(type!) !== -1) {
      this.warnings.push(
        `WARNING: ${el.path} uses the ${type} type in library ${libname}`);
      this.incompleteTypesUsed[type!] = true;
    }
    this.walkChildren(el);
  }
}
