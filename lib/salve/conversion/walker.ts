/**
 * This module contains classes for walking a parsed tree.
 * @author Louis-Dominique Dubeau
 * @license MPL 2.0
 * @copyright Mangalam Research Center for Buddhist Languages
 */

import * as datatypes from "../datatypes";
import * as formats from "../formats";
import { Element, Node, Text } from "./parser";

// Table of names (string) to constructors.(function).
const nameToConstructor: any = formats.__protected.nameToConstructor;
const constructors: Function[] = [];
let ntocIx: number = 0;
while (nameToConstructor[ntocIx] !== undefined) {
  constructors[ntocIx] = nameToConstructor[ntocIx];
  ntocIx++;
}

// Table of names (string) to corresponding type number.
const constructorNameToIndex: {[name: string]: number} = Object.create(null);

for (const name in nameToConstructor) {
  if (!(name in constructors)) {
    // Not a number
    constructorNameToIndex[name] =
      constructors.indexOf(nameToConstructor[name]);
  }
}

type ConstructState = {
  open: string;
  close: string;
  first: boolean;
};

/**
 * Base class for walkers.
 */
export abstract class ConversionWalker {
  protected _output: string = "";

  /** The output of the conversion. */
  get output(): string {
    return this._output;
  }

  private _constructState: ConstructState[] =
    [{ open: "", close: "", first: true }];

  /**
   * Resets the walker to a blank state. This allows using the same walker for
   * multiple walks.
   */
  reset(): void {
    this._output = "";
    this._constructState = [{ open: "", close: "", first: true }];
  }

  /**
   * Opens a construct in the output.
   *
   * @param open The opening string.
   *
   * @param close The closing string. This will be used to check that the
   * construct is closed properly.
   */
  openConstruct(open: string, close: string): void {
    this._constructState.unshift({ open, close, first: true });
    this._output += open;
  }

  /**
   * Closes a construct in the output.
   *
   * @param close The closing string. This will be used to check that the
   * construct is closed properly.
   *
   * @throws {Error} If the ``close`` parameter does not match what was passed
   * to [[openConstruct]].
   */
  closeConstruct(close: string): void {
    const top: ConstructState | undefined = this._constructState.shift();
    if (top !== undefined) {
      if (close !== top.close) {
        throw new Error(`construct mismatch: ${top.close} vs ${close}`);
      }
      this._output += close;
    }
  }

  /**
   * Indicates that a new item is about to start in the current construct.
   * Outputs a separator (",") if this is not the first item in the construct.
   */
  newItem(): void {
    if (!this._constructState[0].first) {
      this._output += ",";
    }
    this._constructState[0].first = false;
  }

  /**
   * Outputs an item in the current construct. Outputs a separator (",") if this
   * is not the first item in the construct.
   *
   * @param item The item to output.
   */
  outputItem(item: string | number): void {
    this.newItem();
    this._output += (typeof item === "number") ? item.toString() : item;
  }

  /**
   * Outputs a string in the current construct. Outputs a separator (",") if
   * this is not the first item in the construct. The double-quotes in the
   * string will be escaped and the string will be surrounded by double quotes
   * in the output.
   *
   * @param thing The string to output.
   */
  outputAsString(thing: string | Node): void {
    this.newItem();
    this._output += JSON.stringify(thing instanceof Node ? thing.text : thing);
  }

  /**
   * Outputs a key-value pair. Both are strings. Outputs a separator (",") if
   * this is not the first item in the construct. The double-quotes in the
   * strings will be escaped and the strings will be surrounded by double quotes
   * in the output.
   *
   * @param key The key to output.
   * @param value The value to output.
   */
  outputKeyValue(key: string, value: string): void {
    this.newItem();

    this._output += `${JSON.stringify(key)}:${JSON.stringify(value)}`;
  }

  /**
   * Walks an element's children.
   *
   * @param el The element whose children must be walked.
   *
   * @param startAt Index at which to start walking.
   *
   * @param endAt Index at which to end walking. If unspecified, go to the end
   * of the children of ``el``.
   */
  walkChildren(el: Element, startAt: number = 0, endAt?: number): void {
    const children = el.children;
    const limit = (endAt === undefined) ? children.length :
      Math.min(endAt, children.length);

    if (limit < startAt) {
      throw new Error("invalid parameters passed");
    }

    for (let i = startAt; i < limit; ++i) {
      const child = children[i];
      if (child instanceof Element) {
        this.walk(child);
      }
    }
  }

  /**
   * Walk an element.
   *
   * @param el The element whose children must be walked.
   */
  abstract walk(el: Element): void;
}

/**
 * [[ConversionWalker]] for the default version generated by salve.
 */
export class DefaultConversionWalker extends ConversionWalker {
  protected readonly arrayStart: string | number;
  protected inNameClass: boolean = false;

  /**
   * @param version The version of the format to produce.
   *
   * @param includePaths Whether to include paths in the output.
   *
   * @param verbose Whether to output verbosely.
   *
   * @throws {Error} If the version requested in ``version`` is not supported.
   */
  constructor(version: number, readonly includePaths: boolean = false,
              readonly verbose: boolean = false) {
    super();
    if (version !== 3) {
      throw new Error("DefaultConversionWalker only supports version 3");
    }
    this.arrayStart = this.verbose ? "\"Array\"" : 0;
  }

  /**
   * Open an array in the output.
   */
  openArray(): void {
    this.openConstruct("[", "]");
    this.outputItem(this.arrayStart);
  }

  // tslint:disable-next-line: max-func-body-length
  walk(el: Element): void {
    const elName = el.local;
    switch (elName) {
      case "start":
        this.walkChildren(el);
        break;
      case "param":
        this.outputAsString(el.mustGetAttribute("name"));
        this.outputAsString(el.children[0]);
        break;
      case "grammar": {
        this.openConstruct("{", "}");
        this.outputItem(`"v":3,"o":${this.includePaths ? 0 :
formats.OPTION_NO_PATHS},"d":`);
        // tslint:disable:no-string-literal
        const ctor = constructorNameToIndex["Grammar"];
        if (ctor === undefined) {
          throw new Error("can't find constructor for Grammar");
        }
        this.openConstruct("[", "]");
        if (this.verbose) {
          this.outputAsString("Grammar");
        }
        else {
          this.outputItem(ctor);
        }
        if (this.includePaths) {
          this.outputAsString(el.path);
        }
        this.walk(el.children[0] as Element);
        this.newItem();
        this.openArray();
        this.walkChildren(el, 1);
        this.closeConstruct("]");
        this.closeConstruct("]");
        this.closeConstruct("}");
        break;
      }
      default: {
        let capitalized: string = el.local.charAt(0).toUpperCase() +
          el.local.slice(1);
        const skipToChildren: boolean = (capitalized === "Except");
        if (this.inNameClass) {
          // When we are in an name class, some elements are converted
          // differently from when outside it. For instance, choice can appear
          // as a general pattern to encode a choice between two elements or
          // two attributes, and it can be used inside a name class to encode a
          // choice between two names. We convert such elements to a different
          // class.
          if (capitalized === "Choice") {
            capitalized = "NameChoice";
          }
        }

        // We do not output anything for this element itself but instead go
        // straight to its children.
        if (skipToChildren) {
          this.walkChildren(el);

          return;
        }

        this.newItem();
        const ctor = constructorNameToIndex[capitalized];
        if (ctor === undefined) {
          throw new Error(`can't find constructor for ${capitalized}`);
        }

        this.openConstruct("[", "]");
        if (this.verbose) {
          this.outputAsString(capitalized);
        }
        else {
          this.outputItem(ctor);
        }
        if (this.includePaths) {
          this.outputAsString(el.path);
        }

        switch (elName) {
          case "ref": {
            const name = el.mustGetAttribute("name");
            if (/^\d+$/.test(name)) {
              this.outputItem(parseInt(name));
            }
            else {
              this.outputAsString(name);
            }
            break;
          }
          case "define": {
            const name = el.mustGetAttribute("name");
            if (/^\d+$/.test(name)) {
              this.outputItem(parseInt(name));
            }
            else {
              this.outputAsString(name);
            }
            this.newItem();
            this.openArray();
            this.walkChildren(el);
            this.closeConstruct("]");
            break;
          }
          case "value": {
            // Output a variable number of items.
            // Suppose item 0 is called it0 and so forth. Then:
            //
            // Number of items  value  type    datatypeLibrary  ns
            // 1                it0    "token" ""               ""
            // 2                it0     it1    ""               ""
            // 3                it0     it1    it2              ""
            // 4                it0     it1    it2              it3
            //
            this.outputAsString(el);
            const typeAttr = el.mustGetAttribute("type");
            const datatypeLibraryAttr = el.mustGetAttribute("datatypeLibrary");
            const nsAttr = el.mustGetAttribute("ns");
            if (typeAttr !== "token" || datatypeLibraryAttr !== "" ||
                nsAttr !== "") {
              this.outputAsString(typeAttr);
              if (datatypeLibraryAttr !== "" || nsAttr !== "") {
                this.outputAsString(datatypeLibraryAttr);
                // No value === empty string.
                if (nsAttr !== "") {
                  this.outputAsString(nsAttr);
                }
              }
            }
            break;
          }
          case "data": {
            // Output a variable number of items.
            // Suppose item 0 is called it0 and so forth. Then:
            //
            // Number of items  type    datatypeLibrary params except
            // 0                "token" ""              {}     undefined
            // 1                it0     ""              {}     undefined
            // 2                it0     it1             {}     undefined
            // 3                it0     it1             it2    undefined
            // 4                it0     it1             it2    it3
            //
            // Parameters are necessarily first among the children.
            const hasParams: boolean =
              (el.children.length !== 0 &&
               ((el.children[0] as Element).local === "param"));
            // Except is necessarily last.
            const hasExcept: boolean =
              (el.children.length !== 0 &&
               (el.children[el.children.length - 1] as Element).local ===
               "except");

            const typeAttr = el.mustGetAttribute("type");
            const datatypeLibraryAttr = el.mustGetAttribute("datatypeLibrary");
            if (typeAttr !== "token" || datatypeLibraryAttr !== "" ||
                hasParams || hasExcept) {
              this.outputAsString(typeAttr);
              if (datatypeLibraryAttr !== "" || hasParams || hasExcept) {
                this.outputAsString(datatypeLibraryAttr);
                if (hasParams || hasExcept) {
                  this.newItem();
                  this.openArray();
                  if (hasParams) {
                    this.walkChildren(el, 0,
                                      hasExcept ? el.children.length - 1 :
                                      undefined);
                  }
                  this.closeConstruct("]");
                  if (hasExcept) {
                    this.walk(el.children[el.children.length - 1] as Element);
                  }
                }
              }
            }
            break;
          }
          case "group":
          case "interleave":
          case "choice":
          case "oneOrMore":
            this.newItem();
            this.openArray();
            this.walkChildren(el);
            this.closeConstruct("]");
            break;
          case "element":
          case "attribute":
            // The first element of `<element>` or `<attribute>` is necessarily
            // a name class. Note that there is no need to worry about recursion
            // since it is not possible to get here recursively from the
            // `this.walk` call that follows. (A name class cannot contain
            // `<element>` or `<attribute>`.
            this.inNameClass = true;
            this.walk(el.children[0] as Element);
            this.inNameClass = false;
            this.newItem();
            this.openArray();
            this.walkChildren(el, 1);
            this.closeConstruct("]");
            break;
          case "name":
            this.outputAsString(el.mustGetAttribute("ns"));
            this.outputAsString(el);
            break;
          case "nsName":
            this.outputAsString(el.mustGetAttribute("ns"));
            this.walkChildren(el);
            break;
          default:
            this.walkChildren(el);
        }
        this.closeConstruct("]");
      }
    }
  }
}

/**
 * A [[ConversionWalker]] specialized in gathering the names used for Relax NG's
 * ``<ref>`` and ``<define>`` elements.
 */
export class NameGatherer extends ConversionWalker {
  /**
   * The names gathered. Each name is associated with the number of times it
   * was seen. This property is valid after the walker has walked the element
   * tree.
   */
  readonly names: {[name: string]: number} =  Object.create(null);

  walk(el: Element): void {
    this.walkChildren(el);
    if (el.local === "define" || el.local === "ref") {
      const name: string = el.mustGetAttribute("name");
      if (!(name in this.names)) {
        this.names[name] = 0;
      }

      this.names[name]++;
    }
  }
}

/**
 * A [[ConversionWalker]] specialized in reassigning the names used by Relax
 * NG's ``<ref>`` and ``<define>`` elements.
 *
 * @param names This is a map whose keys are the names that already exist in the
 * element tree and the values are the new names to use. A ``(key, value)`` pair
 * indicates that ``key`` should be replaced with ``value``. It is up to the
 * caller to ensure that two keys do not share the same value and that the map
 * is complete.
 */
export class Renamer extends ConversionWalker {
  constructor(protected names: {[name: string]: string}) {
    super();
  }

  walk(el: Element): void {
    if (el.local === "define" || el.local === "ref") {
      el.setAttribute("name", this.names[el.mustGetAttribute("name")]);
    }
    this.walkChildren(el);
  }
}

const warnAboutTheseTypes: string[] = [
  "ENTITY",
  "ENTITIES",
];

/**
 * @private
 *
 * @param el Element to start the search from.
 *
 * @returns ``true`` if ``el`` is an attribute or is in an RNG
 * ``<attribute>`` element. ``false`` otherwise.
 */
function inAttribute(el: Element): boolean {
  let current: Element | undefined = el;
  while (current !== undefined) {
    if (current.local === "attribute") {
      return true;
    }
    current = current.parent;
  }

  return false;
}

function localName(value: string): string {
  const sep: number = value.indexOf(":");

  return (sep === -1) ? value : value.slice(sep + 1);
}

function fromQNameToURI(value: string, el: Element): string {
  const attribute: boolean = inAttribute(el);
  let parts: string[] = value.split(":");

  if (parts.length === 1) { // If there is no prefix
    if (attribute) { // Attribute in undefined namespace
      return "";
    }

    // We are searching for the default namespace currently in effect.
    parts = ["", value];
  }

  if (parts.length > 2) {
    throw new Error("invalid name");
  }

  if (parts[0] === "") {
    // Yes, we return the empty string even if that what @ns is set to:
    // there is no default namespace when @ns is set to ''.
    return el.mustGetAttribute("ns");
  }

  // We have a prefix, in which case @ns is useless. We have to get the
  // namespace from the namespaces declared in the XML file that contains the
  // schema. At this stage, @xmlns and @xmlns:prefix attributes are no longer
  // available. So we just ask the element to use its internal namespace data to
  // resolve the prefix.
  const uri: string | undefined = el.resolve(parts[0]);
  if (uri === undefined) {
    throw new Error(`cannot resolve prefix: ${parts[0]}`);
  }

  return uri;
}

/**
 * This walker checks that the types used in the tree can be used, and does
 * special processing for ``QName`` and ``NOTATION``.
 */
export class DatatypeProcessor extends ConversionWalker {
  /**
   * The warnings generated during the walk. This array is populated while
   * walking.
   */
  readonly warnings: string[] = [];

  /**
   * An anonymous object whose keys are the
   * types that have been deemed incomplete. This object is populated while
   * walking walk.
   */
  readonly incompleteTypesUsed: {[name: string]: boolean} = Object.create(null);

  walk(el: Element): void {
    let libname: string | undefined;
    let type: string | undefined; // tslint:disable-line: no-reserved-keywords

    const name = el.local;
    switch (name) {
      case "value": {
        let value = el.text;
        type = el.mustGetAttribute("type");
        libname = el.mustGetAttribute("datatypeLibrary");
        let ns = el.mustGetAttribute("ns");

        const lib = datatypes.registry.find(libname);
        if (lib === undefined) {
          throw new datatypes.ValueValidationError(el.path,
            [new datatypes.ValueError(`unknown datatype library: ${libname}`)]);
        }

        const datatype = lib.types[type];
        if (datatype === undefined) {
          throw new datatypes.ValueValidationError(el.path,
            [new datatypes.ValueError(`unknown datatype ${type} in \
${(libname === "") ? "default library" : `library ${libname}`}`)]);
        }

        if (datatype.needsContext &&
            // tslint:disable-next-line: no-http-string
            !(libname === "http://www.w3.org/2001/XMLSchema-datatypes" &&
              (type === "QName" || type === "NOTATION"))) {
          throw new Error("datatype needs context but is not " +
                          "QName or NOTATION form the XML Schema " +
                          "library: don't know how to handle");
        }

        if (datatype.needsContext) {
          // Change ns to the namespace we need.
          ns = fromQNameToURI(value, el);
          el.setAttribute("ns", ns);
          value = localName(value);
          el.empty();
          el.append(new Text(value));
        }

        const valuePattern =
          new nameToConstructor.Value(el.path, value, type, libname, ns);

        // Accessing the value will cause it to be validated.
        // tslint:disable-next-line:no-unused-expression
        valuePattern.value;
        break;
      }
      case "data": {
        // Except is necessarily last.
        const hasExcept = (el.children.length !== 0 &&
                           (el.children[el.children.length - 1] as Element)
                           .local === "except");

        type = el.mustGetAttribute("type");
        libname = el.mustGetAttribute("datatypeLibrary");
        const lib = datatypes.registry.find(libname);
        if (lib === undefined) {
          throw new datatypes.ValueValidationError(el.path,
            [new datatypes.ValueError(`unknown datatype library: ${libname}`)]);
        }

        if (lib.types[type] === undefined) {
          throw new datatypes.ValueValidationError(el.path,
            [new datatypes.ValueError(`unknown datatype ${type} in \
${(libname === "") ? "default library" : `library ${libname}`}`)]);
        }

        const params = el.children.slice(
          0, hasExcept ? el.children.length - 1 : undefined).map(
            (child: Element) => ({
              name: child.getAttribute("name"),
              value: child.text,
            }));

        const data = new nameToConstructor.Data(el.path, type, libname, params);

        // This causes the parameters to be checked. We do not need to do
        // anything with the value.
        // tslint:disable-next-line:no-unused-expression
        data.params;
        break;
      }
      default:
    }

    // tslint:disable-next-line: no-http-string
    if (libname === "http://www.w3.org/2001/XMLSchema-datatypes" &&
        // tslint:disable-next-line:no-non-null-assertion
        warnAboutTheseTypes.indexOf(type!) !== -1) {
      this.warnings.push(
        `WARNING: ${el.path} uses the ${type} type in library ${libname}`);
      // tslint:disable-next-line:no-non-null-assertion
      this.incompleteTypesUsed[type!] = true;
    }
    this.walkChildren(el);
  }
}

//  LocalWords:  MPL DefaultConversionWalker param includePaths NameChoice ns
//  LocalWords:  datatypeLibrary params oneOrMore nsName RNG xmlns libname el
//  LocalWords:  QName stringify
